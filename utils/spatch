#!/bin/sh
# shellcheck disable=SC2086
# shellcheck disable=SC2181

: <<'notice'
 * SPDX-License-Identifier: GPL-3.0
 *
 * Copyright (C) 2020 Dimitar Yurukov <mscalindt@protonmail.com>
 *
notice

usage() {
printf "%s" "\
Usage: spatch [options] [--] FILE
Sort commit/patch links by date.

Options:
  -i, --invert    sort from newest to oldest
  -t, --target=PATH   PATH is an absolute or relative location to which
                      the final file shall be written
      --help      display this help text and exit
      --          end of options

Unless -t / --target is specified, FILE will be overwritten.
"
}

# Description:
# Check command availability
#
# Parameters:
# $1 - command
#
# Returns:
# true (0) if command available,
# false (127) if not
#
cmd_avail() {
    if command -v $1 > /dev/null 2>&1; then
        return 0
    fi

    return 127
}

# Description:
# Check if a substring is present in a string
#
# Parameters:
# $1 - substring
# $2 - string
#
# Returns:
# true (0) if substring is present,
# false (1) if not
#
grep_str() {
    if printf "%s" "$2" | grep -Fq -- "$1"; then
        return 0
    fi

    return 1
}

# Description:
# Get substring after specific character(s) in a string
#
# Parameters:
# $1 - character(s)
# $2 - string
#
# Returns:
# {string} if $2 = 'str$1string',
# false (1) if error
#
substr_after() {
    i=${#1}
    i=$((i + 1))
    i=$(printf "%s" "$2" | grep -Eo -- "$1[^[:space:]]+" | cut -c ${i}-)
    if [ -n "$i" ]; then
        printf "%s" "${i}"
        return 0
    fi

    return 1
}

# Description:
# Print error in red and exit
#
# Parameters:
# $1 - error message
# $2 - exit code
#
err() {
    printf "%b" "\033[1;31m"
    echo
    printf "%s" "$1"
    echo && echo
    printf "%b" "\033[0m"
    exit $2
}

# Description:
# Print warn in yellow
#
# Parameters:
# $1 - warn message
#
warn() {
    printf "%b" "\033[1;33m"
    printf "%s" "$1"
    echo
    printf "%b" "\033[0m"
}

# Description:
# Redirect information from source file to target file
#
# Parameters:
# $1 - source file
# $2 - target file
#
rdr() {
    rm -f "$2" && cat "$1" > "$2"
    rm -f "$1"
}

spatch_work() {
    TMP_DIR="$HOME"/.spatch_tmp_dir
    TMP_FILE="$HOME"/.spatch_tmp_file
    TMP_FILE2="$HOME"/.spatch_tmp_file2

    rm -rf "$TMP_DIR" && mkdir "$TMP_DIR"
    rm -f "$TMP_FILE"
    rm -f "$TMP_FILE2"
}

spatch_exec() {
    if [ ! -f "$1" ]; then
        spatch_post;
        err "$1 is not a file" "1"
    fi

    while read -r LINE || [ -n "$LINE" ]; do
        URL=$(printf "%s" "$LINE" | grep -Eo '[^[:space:]]+://[^[:space:]]+')

        if [ $? -ne 0 ]; then
            if [ -n "$LINE" ]; then
                warn "No URL string (*://*) found in '$LINE'"
            fi
            continue
        fi

        if ! grep_str ".patch" "$URL"; then
            URL=${URL}.patch
        fi

        if cmd_avail curl; then
            cd "$TMP_DIR" || err "Line $LINENO failed" "1"
            curl -Of $URL
        elif cmd_avail wget; then
            wget -P "$TMP_DIR" $URL
        else
            spatch_post;
            err "No file download tool available (curl/wget)" "127"
        fi

        if [ $? -ne 0 ]; then
            spatch_post;
            err "Failed to download $URL" "1"
        fi
    done < "$1"

    PATCHES="$TMP_DIR/*"
    for PATCH in $PATCHES; do
        CSTR=$(sed '1q;d' $PATCH | cut -d ' ' -f2)
        DSTR=$(sed '3q;d' $PATCH | cut -d ' ' -f3,4,5,6)

        printf "%s %s\n" "${CSTR}" "${DSTR}" >> "$TMP_FILE"
    done

    sort -t " " -k4.1,4.4 \
                -k3.1,3.3M \
                -k2.1n \
                -k5.1,5.2 \
                -k5.4,5.5 \
                -k5.7,5.8 "$TMP_FILE" > "$TMP_FILE2"
    rdr "$TMP_FILE2" "$TMP_FILE"

    if [ -n "$invert" ]; then
        awk '{a[i++]=$0;} END {for (j=i-1; j>=0;) print a[j--];}' \
            "$TMP_FILE" > "$TMP_FILE2"
        rdr "$TMP_FILE2" "$TMP_FILE"
    fi

    if [ -n "$target" ]; then
        rdr "$TMP_FILE" "$target"
    else
        rdr "$TMP_FILE" "$1"
    fi
}

spatch_post() {
    rm -rf "$TMP_DIR"
    rm -f "$TMP_FILE"
    rm -f "$TMP_FILE2"
}

spatch() {
    spatch_work;
    spatch_exec "$1"
    spatch_post;
}

main() {
    # Serve the script until no script parameters passed
    while [ "$1" ]; do
        case "$1" in
            "-i" | "--invert") invert=1 && shift ;;
            "-t")
                if [ "$2" ]; then
                    target="$2" && shift
                fi

                if [ "$(printf "%s" "$target" | cut -c 1)" != "/" ]; then
                    target="$(printf "%s/%s" "$PWD" "$target")"
                fi

                shift
            ;;
            "--target="*)
                if ! grep_str " --target= " " $1 "; then
                    target="$(substr_after "=" "$1")"
                fi

                if [ "$(printf "%s" "$target" | cut -c 1)" != "/" ]; then
                    target="$(printf "%s/%s" "$PWD" "$target")"
                fi

                shift
            ;;
            "--help") usage && return 0 ;;
            *) break ;;
        esac
    done

    # Catch end of options (parameters)
    if grep_str " -- " " $1 "; then
        shift
    fi

    # Catch wrong input
    if [ ! "$1" ] || [ "$2" ]; then
        usage && return 1
    fi

    # Convert relative path to absolute path
    if [ "$(printf "%s" "$1" | cut -c 1)" != "/" ]; then
        fpath="$(printf "%s/%s" "$PWD" "$1")"
        set -- "$fpath"
    fi

    # Execute the core function
    spatch "$1"

    # Explicit success
    return 0
}

main "$@"
